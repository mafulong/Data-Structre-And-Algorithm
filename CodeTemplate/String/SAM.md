## 后缀自动机

这篇[博客](https://www.cnblogs.com/zjp-shadow/p/9218214.html)已经讲的非常清楚了，这里的主要部分就是转载。后面加上自己的一些总结。

![后缀自动机](SAM/1.png)


### 重点归纳

1. 后缀自动机中存储了一个字符串所有子串的信息，这个自动机可接受的状态是一个字符串的所有后缀。自动机上的每个路径都代表着原串中的一个子串。后缀自动机中每个节点代表一些子串，这些子串的`endpos`集合相同，由`endpos`集合相同可以推导出，这些子串是这个集合中表达是最长子串的连续后缀。
2. 每个节点有一个后缀链接链接到其它节点，其中链接到的节点表示这个节点代表的子串集合中最短的子串前面删除一个字符得到的字符串，这个字符串在它后缀链接链到的节点中是最长的。
3. 从任何一个节点出发，通过一系列的后缀链接，可以遍历到这个节点代表的最长字符串的所有后缀。
4. 从代表整个子串的节点出发，沿着后缀链接遍历到的点是后缀自动机的可接受状态即可。任何一个序列从起点开始在自动机上跳转，如果最终停止到这些可接受状态，则表示输入的序列是一个后缀。
5. 每个状态代表的本质不同的字符串的个数是`tr[node].len  - tr[tr[node].fa].len`，既当前节点代表的最大字符串长度减去其后缀链接到的节点代表的最大字符串的长度。
6. 每个状态的`endpos`集合的大小的计算方式如下：
   - 一个状态代表的所有字符串出现的次数都是相同的，所以只需要考虑这个状态代表的最长的字符串出现的次数。
   - 如果当前状态`st1`代表的最长的字符串出现的位置不是原字符串的前缀，那么这个字符串前面必然可以添加字符，那么添加字符得到的这个字符串必然属于某个状态`st2`，且这个`st2`状态的后缀链接指向了`st1`。所以每个状态的`endpos`集合的大小是后缀链接指向它的状态的`endpos`集合的大小的和。
   - 如果当前状态`st1`代表的最长字符串在原串的前缀中出现过，由于每个字符串只可能在一个前缀的地方出现，一个前缀长度也智能对应一个字符串，所以可以在增量创建SAM的时候记录一下原串的每个前缀所处的状态，然后再这个状态上加1.

[代码模板](SAM.cpp)

[代码模板_类实现](SAM2.cpp)

